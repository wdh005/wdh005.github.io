---
title:  "CSS 개요 / 속성"
excerpt: "CSS 심화 정리 "
header:
  teaser: /assets/images/css3.png
categories:
  - 내용정리
  - 공부
tags:
  - css
date : "2020-06-30 23:50"
---

# 기본 문법

---

## 선택자(selector)의 역할

---

* 속성과 값을 지정할 (html)대상을 검색 (선택자를 잘 사용해야 css를 제대로 적용할 수 있다.)

## 속성(property)과 값(value)의 역할

---

* (선택자로)검색된 대상에 지정될 css 명령

## 주석

---

* 문서 내 수정사항이나 설명 등을 작성
> /* Comment */ (작성법)


# CSS 선언 방식

---

## 인라인(in-line) 방식

---

* HTML 태그의 `style`속성에 직접 작성하는 방식
-> 선택자가 필요하지 않다.

## 내장(embedded)방식

---

* HTML `<style></style>`안에 작성하는 방식

## 링크(link)방식

---

* HTML `<link>`를 이용하여 외부 문서로 CSS를 불러와 적용하는 방식

## `@import` 방식

---

* `@` -> at규칙
* CSS `@import`를 이용하여 외부 문서로 CSS를 불러와 적용하는 방식
* CSS에서 외부의 CSS를 가져오는 방식 
* 직렬 호출 방식이므로 사용시 주의가 필요함 

# 선택자(selector)

---

## 기본 선택자(Basic Selectors)

1. 전체 선택자(Universal Selector)
  - (요소 내부의)모든 요소를 선택
  - `*` 기호

2. 태크 선택자(Type Selector)
  - 태그 이름 요소 선택
  - `html요소이름`
3. 클래스 선택자(Class Selector)
  - HTML class 속성의 값 요소 선택
  - `.class-name`

4. 아이디 선택자(ID Selector)
  - HTML id 속성의 값 요소 선택
  - `#id-name`

---

## 복합 선택자

1. 일치 선택자(Basic Combinator)
  - 요소1과 요소2를 동시에 만족하는 요소 선택
  - `요소1요소2`  
  - 요소1과요소2를 붙여서 사용
  - > ex) span.orange{ color:red; } -> class 이름이 orange인 span태그를 선택

2. 자식 선택자(Child Combinator)
  - 요소1의 자식 요소 요소2를 선택
  - `요소1 > 요소2`
  - > ul > .orange { color: red; } -> ul 태그의 자식요소 중 class 이름이 orange인 요소를 선택

3. 자손(후손, 하위) 선택자(Descendant Combinator)
  - 요소1의 후손 요소2를 선택
  - `요소1 요소2`
  - `띄어쓰기`가 선택자의 기호로 사용된다.
  - > div .orange { color: red; } -> div 태그의 후손(div 태그에 속해 있는 모든 요소) 중 class 이름이 orange인 요소를 선택 

4. 인접 형제 선택자(Adjacent Sibling Combinator)
  - 요소1의 다음 형제 요소2 하나만 선택
  - `요소1 + 요소2`
  - > .orange + li { color:red; } -> orange라는 class를 가진 요소 다음에 있는 li요소를 선택 ( 같은 부모 요소내에 있는 ) 
  
  ```html
  <ul>
    <li>딸기</li>
    <li>수박</li>
    <li class="orange">오렌지</li>
    <li>망고</li> <!-- 선택된 요소 -->
    <li>복숭아</li>
  </ul>
  ```
5. 일반 형제 선택자(General Sibling Combinator)
  - 요소1 다음 형제 요소 모두 선택
  - `요소1 ~ 요소2`
  - > .orange ~ li { color:red; } -> orange라는 class를 가진 요소 다음에 있는 모든 li요소를 선택 ( 같은 부모 요소내에 있는 ) 

  ```html
  <ul>
    <li>딸기</li>
    <li>수박</li>
    <li class="orange">오렌지</li>
    <li>망고</li> <!-- 선택된 요소 -->
    <li>복숭아</li> <!-- 선택된 요소 -->
    <li>사과</li> <!-- 선택된 요소 -->
  </ul>
  ```

---

## 가상 클래스 선택자(Pseudo-Classes Selectors)
- 콜론기호(`:`)가 하나 붙어 있다

1. HOVER
  - 요소에 마우스(포인터)가 올라가 있는 동안에만 요소 선택
  - `요소:hover`

2. ACTIVE
  - 요소를 마우스로 클릭하는 동안에만 요소를 선택
  -`요소:active`

3. FOCUS
  - 요소가 포커스 된 동안에만 요소를 선택
  - `요소:focus`
  - > 대화형 콘텐츠에서 사용 가능

4. FIRST CHILD
  - 요소가 형제 요소 중 첫번째 요소라면 선택
  - `요소:first-child`
  - > .classname li:first-child { color:red; }

5. LAST CHILD
  - 요소가 형제 요소 중 마지막 요소라면 선택
  - `요소:last-child`
  - > .classname li:last-child { color:red; }

6. NTH CHILD
  - 요소가 형제 요소 중에 `n`번째 요소라면 선택
  - `n` 키워드 사용시 0부터 해석 (Zero-base)
  - `요소:nth-child(n)`
  - > .classname li:nth-child(2) {color: red; }
  - > .classname li:nth-child(2n) {color: red; } -> 짝수 번째 요소들만 선택
  - > .classname li:nth-child(n+3) {color: red; } -> 3번째 요소부터 이후 요소들을 선택

7. XXX-CHILD 주의 사항

> .classname p:nth-child(1) {color:red;}
```html
<div class="classname">
  <div>A</div>
  <p>B</p>
  <p>C</p>
  <p>D</p>
  <span>E</span>
</diV>
```
위 경우 첫번째 자식 요소가 `<p>`가 아니고 `<div>` 이므로 선택되는 요소가 없다.

8. NTH OF TYPE
  - 요소의 타입(태그이름)과 동일한 타입인 형제 요소중 요소가 `n`번째 요소라면 선택
  - `n` 키워드 사용시 0부터 해석 (Zero-base)
  - `요소:nth-of-type(n)`
  - 태그를 찾는 개념으로 사용 (요소 부분에 class, id를 사용하지 않고 태그를 사용해야 한다.)
  - > .classname li:nth-of-type(1) { color:red; } ->classname의 자손 중 첫번째 li요소를 선택

9. 부정 선택자(Negation Selector)
  - 선택자가 아닌 요소 선택
  - `요소:not(선택자)`
  - > li:not(.classname) -> 선택에서 제외할 class(선택자)를 지정 

## 가상 요소 선택자(Pseudo-Elements Selectors)
- 콜론기호(`::`) 2개를 사용한다.
---

1. BEFORE
  - `E`요소 내부의 앞에, 내용(content)을 삽입
  - `E::before`
  - > li::before { content: "내용"; } -> li태그 안에 "내용"을 추가한다

  ```html
    <li>사과</li>
    <li>딸기</li>
    <li>포도</li>
    <li>귤</li>
  ```

  ```css
    li::before {
      content: "like";
    }
  ```

  ```
    like사과
    like딸기
    like포도
    like귤
  ```
  > before의 속성 content에서 추가한 내용이 앞에 삽입된다. 삽입된 내용에 css적용도 가능하다 (content라는 속성을 무조건 사용해야 된다!! 내용을 적지 않아도 필수로 입력해야 함)

2. AFTER
  - `E`요소 내부의 뒤에, 내용(content)을 삽입
  - `E::after`
  - > li::after { content: "내용"; } -> li태그 안에 "내용"을 추가한다

    ```html
    <li>사과</li>
    <li>딸기</li>
    <li>포도</li>
    <li>귤</li>
  ```

  ```css
    li::after {
      content: "like";
    }
  ```

  ```
    사과like
    딸기like
    포도like
    귤like
  ```

   > after의 속성 content에서 추가한 내용이 뒤에 삽입된다. 삽입된 내용에 css적용도 가능하다 (content라는 속성을 무조건 사용해야 된다!! 내용을 적지 않아도 필수로 입력해야 함)

  > content속성에 이미지도 사용가능 하다 , content: url("imageURL주소")

## 속성 선택자(Attribute Selector)
- html의 속성을 의미

1. ATTR
  - 속성 `attr`을 포함한 요소 선택
  - `[attr]`

2. ATTR=VALUE
  - 속성 `attr`을 포함하며 속성값이 `value`인 요소 선택
  - `[attr=value]`

3. ATTR^=VALUE
  - 속성 `attr`을 포함하며 속성값이 `value`로 시작하는 요소 선택
  - `[attr^=value]`

4. ATTR$=VALUE
  - 속성 `attr`을 포함하며 속성값이 `value`로 끝나는 요소 선택
  - `[attr$=value]`

## 상속(Inheritance)

- 특정한 css 속성들은 모든 하위 요소들에게도 적용된다. -> 상속의 개념 
- 상속되는 속성들 
    - font
      * font-size
      * font-weight
      * font-style
      * font-height
      * font-family
    - color
    - text-align
    - text-indent
    - text-decoration
    - letter-spacing
    - opacity
    - ....
- 강제 상속

  - .parent { position: absolute; }
  - .child { position: inherit; } -> 강제 상속받아 부모의 position 값인 absolute 와 동일

  > 상속되지 않는 속성(값)도 `inherit`이라는 값을 사용하여 부모에서 자식으로 강제 상속시킬 수 있다. 자식을 제외한 후손에게는 적용되지 않으며, 모든 속성이 강제 상속을 사용할 수 있는 것은 아니다.

## 우선순위

- 우선순위 결정
  같은 요소가 여러 선언의 대상이 될 경우, 어떤 선언의 CSS속성(property)을 우선 적용할지 결정하는 방법

  1. 명시도 점수가 높은 선언이 우선(명시도)
  2. 점수가 같은 경우, 가장 마지막에 해석(늦게 작성한)되는 선언이 우선(선언 순서)
  3. 명시도는 `상속`규칙보다 우선(중요도)
  4. `!important`가 적용된 선언 방식이 다른 모든 방식보다 우선(중요도)

  > 우선 순위에는 '중요도, 명시도, 선언 순서'의 개념이 있다. 각 개념이 의미하는 것을 잘 기억해야 한다.

1. 가장 중요(!important)
  - 모든 선언을 무시하고 가장 우선

2. 인라인 선언 방식(Style Attribute)
  - 인라인 선언(HTML `style` 속성을 사용)
  - 점수: 1000pt 

3. 아이디(ID Selector)
  - 아이디 선택자
  - 점수: 100pt

4. 클래스 선택자(Class Selector)
  - 클래스 선택자
  - 점수: 10pt

5. 태그(Type Selector)
  - 태그 선택자
  - 점수: 1pt

6. 전체(Universal Selector)
  - 전체 선택자
  - 점수 : 0pt

7. 상속(CSS Inheritance)
  - 상속 받은 속성은 항상 우선하지 않음
  - 점수 계산하지 않음
  




